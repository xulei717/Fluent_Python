### chapter8 对象引用、可变性和垃圾回收

**1.变量不是盒子，在附加在对象上的标注。**

**2.赋值语句的右边先执行**
* 对象在赋值之前就创建了。
* 为了理解Python的赋值语句，应该始终先读右边。
* 对象在右边创建或获取，在此之后左边的变量才会绑定到对象上，这就像为对象贴上标注。
* 变量只不过是标注，所以无法阻止为对象贴上多个标注。
* 贴的多个标注，就是别名。

**3.每个变量都有标识、类型和值。**
* 变量保存的是引用。
* 对象一旦创建，标识就不会变；可以把标识理解为对象在内存中的地址。
* 只有对象的值会不时改变。
* is运算符比较两个对象的标识。
* id()函数返回对象标识的整数表示。
* == 比较的就是对象的值（对象中保存的数据）。
* 对+=或*=所做的增量赋值，如果左边的变量绑定的是不可变对象，对创建新对象，如果是可变对象，会就地修改。
* 为现有的变量赋予新值，不会修改之前绑定的对象，这叫重新绑定：现有变量绑定了其他对象。如果变量是之前那个对象的最后一个引用，对象会被当作垃圾回收。

**4.在变量和单例值之间比较时，应该使用is**
* x is None
* x is not None

**5.is运算符比==速度快**
* 因为is运算符不能重载，所以Python不用寻找并调用特殊方法，而是直接比较两个整数ID。

**6.a == b是语法糖，等同于a.__eq__(b)**

**7.元组和多数Python集合（列表、字典、集等）一样，保存的是对象的引用。**
* 而str、bytes和array.array等单一类型序列是扁平的，它们保存的不是引用，而是在连续的内存中保存数据本身（字符、字节和数字）。
* 如果引用的元素是可变的，即便元组本身不可变，元素依然可变。
* 元组的不可变性其实是指tuple数据结构的物理内容（即保存的引用）不可变，与引用的对象无关。
* 元素汇总不可变的是元素的标识。

**8.浅复制：复制了最外层容器，副本中的元素是源容器中元素的引用。**
* 浅复制后变量的ID是不一样的，但是值引用的是同一些对象。
* 构造方法或[:]，tuple()做的是浅复制。

**9.深复制：副本不共享内部对象的引用**
* copy模块：提供的deepcopy和copy函数能为任意对象做深复制和浅复制。
* list(可迭代集合)会创建可迭代集合的副本，拥有新的ID。

**10.python唯一支持的参数传递模式是共享传参。**
* 共享传参 call by sharing：指函数的各个形式参数获得实参中各个引用的副本。也就是说，函数内部的形参是实参的别名。
* 函数可能会修改作为参数传入的可变对象，但是没法修改那些对象的标识（即不能把一个对象替换成另一个对象）
* 不要使用可变类型作为参数的默认值
* 通常使用None作为接收可变值的参数的默认值。
* 解决传入的参数是可变参数：让类自己维护一个列表，就是构建一个传入参数的副本，可用self.pas = list(pas)实现。

**11.del语句删除名称，而不是对象**
* del命令可能会导致对象被当作垃圾回收，但是仅当删除的变量保存的是对象的最后一个引用，或者无法得到对象时（两个对象相互引用）。
* 重新绑定也可能会导致对象的引用数量归零，导致对象被销毁。

**12.在CPython中，垃圾回收使用的主要算法是引用计数。**
* 实际上，每个对象都会统计有多少引用指向自己。
* 当引用计数归零时，对象立即就被销毁：CPython会在对象上调用__del__方法（如果定义了），然后释放分配给对象的内存。

**13.弱引用：不会增加对象的引用数量。**
* 弱引用的目标对象称为所指对象 referent。
* 弱引用不会妨碍所指对象被当作垃圾回收。
* 弱引用在缓存应用中很有用，因为不想仅因为被缓存引用着而始终保存缓存对象。
* 弱引用是可调用的对象，返回的是被引用的对象；如果所指对象不存在了，返回None。
* weakref模块：
  * weakref.ref类其实是底层接口，供高级用途使用。
  * 多数程序最好使用wakref集合和finalize。
  * 也就是说，应该使用WeakKeyDictionary,WeakValueDictionary,WeakSet和finalize(在内部使用弱引用)
  * 不要自己动手创建并处理weakref.ref实例。
  * WeakValueDictionary类实现的是一种可变映射，值是对象的弱引用。被引用的对象在程序中的其他地方被当作垃圾回收后，对应的键会自动从WeakValueDictionary中删除。因此，经常用于缓存。
  * WeakKeyDictionary类是key是对象的弱引用。可以为应用中的其他部分拥有的对象添加数据，这样就无需为对象添加属性。这对覆盖属性访问权限的对象尤其有用。
  * WeakSet类：作用是保存元素弱引用的集合类。
  * 类存在的时间与Python进程一样长，除非显示删除类。
* 不是每个Python对象都可以作为弱引用的目标（所指对象）。
  * list和dict实例不能作为所指对象，但是它们的子类可以作为。
  * set实例和用户定义的类型可以作为所指对象。
  * int和tuple实例不能作为弱引用的目标，甚至子类也不行。

**14.可变对象还是导致多线程编程难以处理的主要原因，因为某个线程改动对象后，如果不正确同步，拿就会损坏数据。但是过度同步又会导致死锁。**
  
    
  
  
  
